# {{nebula.name}} 查询语句概述

本文介绍 {{nebula.name}} 的查询语句分类及各个语句的使用场景。

## 背景信息

{{nebula.name}} 的数据以点和边的形式存储。每个点可以有 0 或多个标签（Tag）；每条边有且仅有一个边类型（Edge Type）。标签定义点的类型以及描述点的属性；边类型定义边的类型以及描述边的属性。在查询时，可以通过指定点的标签或边的类型来限定查询的范围。更多信息，请参见[数据模型](../1.nGQL-overview/3.graph-patterns.md)。

## 查询语句分类

{{nebula.name}} 的核心查询语句可分为：

- [FETCH PROP ON](4.fetch.md)
- [LOOKUP ON](5.lookup.md)
- [GO](3.go.md)
- [MATCH](2.match.md)
- [FIND PATH](../16.subgraph-and-path/2.find-path.md)
- [GET SUBGRAPH](../16.subgraph-and-path/1.get-subgraph.md)

`FETCH PROP ON`和`LOOKUP ON`更多用于数据检索；`GO`和`MATCH`用于更复杂的查询和图数据遍历；`FIND PATH`和`GET SUBGRAPH`用于图数据的路径查询和子图查询。

## 用法及使用场景

### FETCH PROP ON 查询属性

**用法**：用于获取指定点或边的属性。

**场景**：已知具体的点 ID 或边 ID，并想获取其属性时使用。

**说明**：

- 必需指定点或边的 ID。
- 必需指定点或边所属的标签或边类型。
- 使用`YIELD`子句指定返回的属性。
  
**示例**：

```ngql
FETCH PROP ON player "player100" YIELD properties(vertex);
              ──┬───  ────┬─────       ─────────┬──────── 
                │         │         ┌───────────┘         
                │         │         │                     
                │         │         └─────── 返回点的 player TAG 下所有属性
                │         │                               
                │         └───────────────── 从 "player100" 这个点获取
                │                                         
                └─────────────────────────── 获取 player 这个 TAG 下的属性
```

更多信息，请参见[FETCH PROP ON](4.fetch.md)。

### LOOKUP ON 查询 ID

**用法**：用于基于索引查询点或边 ID。

**场景**：需要根据属性值查找点或边的 ID 时使用。

**说明**：

- 必需预先定义[索引](../14.native-index-statements/README.md)。
- 必需指定点或边所属的标签或边类型。
- 使用`YIELD`子句指定返回的 ID。
  
**示例**：

```ngql
LOOKUP ON player WHERE player.name == "Tony Parker" YIELD id(vertex);
          ──┬───  ──────┬──────────────────────────  ──┬──────       
            │           │          ┌───────────────────┘             
            │           │          │                                 
            │           │          └──────────── 返回查到点的 VID
            │           │                                            
            │           └─────────────────────── 过滤条件是属性 name 的值
            │                                                        
            └─────────────────────────────────── 根据点的 TAG player 查询
```

更多信息，请参见[LOOKUP ON](5.lookup.md)。

### GO 基于点的图遍历

**用法**：用于基于给定的点进行图遍历，按需返回起始点、边或目标点的信息。可以指定遍历的深度、边的类型、方向等。

**场景**：用于复杂的图遍历，比如找到某个点的朋友、朋友的朋友等。

**说明**：

- 结合[属性引用符](../5.operators/5.property-reference.md)(`$^`和`$$`)来返回起始点或目标点的属性，例如`YIELD $^.player.name`。
- 结合[函数](../6.functions-and-expressions/4.schema.md)`properties($^)`和`properties($$)`来返回起始点或目标点的所有属性；或者在函数中指定属性名，来返回指定的属性，例如`YIELD properties($^).name`。
- 结合[函数](../6.functions-and-expressions/4.schema.md)`src(edge)`和`dst(edge)`来返回边的起始点或目标点 ID，例如`YIELD src(edge)`。

**示例**：

```ngql
GO 3 STEPS FROM "player102" OVER follow YIELD dst(edge);
   ───┬───      ───┬───────      ─┬────       ──┬────── 
      │            │              │   ┌─────────┘       
      │            │              │   │                 
      │            │              │   └── 返回最后一跳边的终点
      │            │              │                     
      │            │              └────── 从 follow 这个边[出方向]探索
      │            │                                    
      │            └───────────────────── 起点是 "player102"
      │                                                 
      └────────────────────────────────── 探索 3 步
```

更多信息，请参见[GO](3.go.md)。

### MATCH 基于图的模式匹配

**用法**：用于执行复杂的[图模式](../1.nGQL-overview/3.graph-patterns.md)匹配查询。

**场景**：需要进行复杂的图模式匹配时使用，比如寻找满足特定模式的点和边的组合。

**说明**：

MATCH 语句兼容 OpenCypher 的语法，但是有一些差异：

- 使用`==`表达相等判断而不是`=`，例如`WHERE player.name == "Tony Parker"`。

- 引用点的属性时，需要指定点的标签，例如`YIELD player.name`。
  
- 新增`WHERE id(v) == "player100"`语法。
  
- 必须使用`RETURN`子句指定返回的信息

**示例**：

```ngql
MATCH (v:player{name:"Tim Duncan"})--(v2:player) \
        RETURN v2.player.name AS Name;
```

更多信息，请参见[MATCH](2.match.md)。


### FIND PATH 路径查询

**用法**：用于查询给定的起始点和目标点之间的所有路径；或者查询路径中的点和边的属性时使用。

**场景**：需要查询两个点之间的所有路径时使用。

**说明**：必须使用`YIELD`子句指定返回信息。

**示例**：

```ngql
FIND SHORTEST PATH FROM "player102" TO "team204" OVER * \   
     ──┬─────            ───────────┬─────────── ───┬───    
  YIELD│path AS p; ┌────────────────┘               │       
       │────┬────  │     ┌──────────────────────────┘       
       │    │      │     │                                  
       │    │      │     └───────── 经由所有类型的边出向探索
       │    │      │                                        
       │    │      └─────────────── 从给定的起点、终点 VID
       │    │                                               
       │    └────────────────────── 返回路径为 p 列
       │                                                    
       └─────────────────────────── 查找最短路径
```

更多信息，请参见[FIND PATH](../16.subgraph-and-path/2.find-path.md)。


### GET SUBGRAPH 子图查询

**用法**：提取满足特定条件的图的一部分；查询子图中的点和边的属性。

**场景**：需要分析图的局部结构或特定区域时非常有用，比如提取某个人的社交网络子图，或者提取某个区域的交通网络。

**说明**：必须使用`YIELD`子句指定返回信息。

**示例**：

```ngql
GET SUBGRAPH 5 STEPS FROM "player101" \           
             ───┬─── ─────┬──────────             
  YIELD VERTICES AS nodes, EDGES AS relationships;
        ────┬───┼─────────┼───────────────────────
   ┌────────┘   │         │                       
   │            │         └─────── 从 "player101" 开始出发
   │            │                                 
   │            └───────────────── 获取 5 步的探索
   │                                              
   └────────────────────────────── 返回所有的点、边
```

更多信息，请参见[GET SUBGRAPH](../16.subgraph-and-path/1.get-subgraph.md)。

## 复合查询

{{nebula.name}} 的查询语句可以组合使用，以实现更复杂的查询。

复合语句中如需引用子查询的结果，需要为该结果设置别名，并使用[管道符`|`](../5.operators/4.pipe.md)传递给下一个子查询，同时在下一个子查询中使用`$-`引用该结果的别名。详情参见[管道符](../5.operators/4.pipe.md)。

示例：

```ngql
nebula> GO FROM "player100" OVER follow \
        YIELD dst(edge) AS dstid, properties($$).name AS Name | \
        GO FROM $-.dstid OVER follow YIELD dst(edge);

+-------------+
| dst(EDGE)   |
+-------------+
| "player100" |
| "player102" |
| "player125" |
| "player100" |
+-------------+
```

管道符`|`仅适用于 nGQL，不适用于 OpenCypher 语句，即不适合在 MATCH 语句中使用管道符。如果需要使用 MATCH 语句进行复合查询，可以使用 [WITH 子句](../8.clauses-and-options/with.md)。